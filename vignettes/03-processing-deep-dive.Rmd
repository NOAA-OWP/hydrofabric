---
title: "Network Manipulation"
description: |
  "Meeting model application needs through refactoring, aggregating, and data modeling"
author:
  - name: "Mike Johnson"
    url: https://github.com/mikejohnson51
    affiliation: Lynker, NOAA-Affiliate
    affiliation_url: https://lynker.com
  - name: "David Blodgett"
    url: https://github.com/dblogett
    affiliation: USGS WMA
output:
  distill::distill_article:
    toc: true
    toc_depth: 2
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(  collapse = TRUE,
  comment = "#>",
  out.width = "100%",
  warning = FALSE, message = FALSE)
library(hydrofabric)
library(ggplot2)
using_local_example = "/Users/mjohnson/hydrofabric"
hf <- "tutorial/poudre.gpkg"
```

# Network Manipulation: Geoprocessing

```{r, echo = FALSE}
knitr::include_graphics('../man/figures/level2.png')
```

# Getting the reference fabric

All reference and (precomputed) refactored data products live on ScienceBase. They can be accessed with the web interface or can be downloaded programatically. The `hydrofab::get_hydrofabric()` utility will download the most current geofabric for a Vector Processing Unit (VPU). Options include downloading the "refactored" (default) or "reference" data. If the requested file already exists, the file path will be returned. 

## Example

- To exemplify this process we do the following:
  1. Define a terminal location of interest
  2. Subset the upstream reference fabric using `hydrofab::subset_reference`

```{r, eval = FALSE}
library(hydrofabric)
using_local_example = "/Users/mjohnson/hydrofabric"

# Define starting feature by source and ID
(gage = list(featureSource = "nwis", featureID = "06752260"))

# Use subset_network to build a reference subset
hf = hfsubsetR::get_subset(nldi_feature = gage, 
                           source  = using_local_example, 
                           outfile = "tutorial/poudre.gpkg",
                           overwrite = FALSE)
```

```{r}
d = read_hydrofabric("tutorial/poudre.gpkg")

pois = open_dataset(glue("{using_local_example}/v2.2/conus_hl")) %>% 
  filter(hf_id %in% d$flowpaths$id, hl_source == 'GFv20') %>% 
  collect() %>% 
  st_as_sf(coords = c("X", "Y"), crs = 5070)
```

# 1) Running the Process: Refactoring

## Concept

- Refactoring is a geoprocessing workflow that seeks to 

   1. Split large or long catchments into a more uniform catchment size distribution and
   2. collapse catchment topology to eliminate small catchments
   
- The key is that no network resolution is lost! That means the total path length of the network going in, is what comes out.

- The workflow is can be parameterized using three primary values:

| Parameter        | Purpose           | Elected Value  | 
| ------------- |:-------------:| -----:| 
| split_flines_meters      | the maximum length flowpath desired in the output. | 10,000|
| collapse_flines_meters      | the minimum length of inter-confluence flowpath desired in the output. | 1,000 |
| collapse_flines_main_meters      | the minimum length of between-confluence flowpaths.| 1,000 |

You might also have areas where you want to avoid, or, enforce a splitting event. These can be defined with the following values:

| Parameter        | Purpose  | 
| ------------- |:-------------:|
| exclude_cats      | 	integer vector of COMIDs to be excluded from collapse modifications. |
| events      | data.frame containing events as generated by get_flowline_index() |

- POI definition and selection is _model application specific_. Here, we will ignore this aspect.

- With only information about the network, refactor can only refactor the flowpath network. 

- In order to reconcile the catchment network,a set of flow accumulation (FAC) and flow direction (FDR) grids must be provided.

 - For the reference fabric (e.g. NHDPlusV2), we supply a national VRT for each of these that can be accessed at: `s3://nextgen-hydrofabric/DEM-products/{product}.vrt`
 
- These (and other gridded products) can be found [here](https://nextgen-hydrofabric.s3.amazonaws.com/index.html#DEM-products/)
 
## Example

```{r, eval = FALSE}
refactored = refactor(hf,
                      split_flines_meters = 10000, 
                      collapse_flines_meters = 1000, 
                      collapse_flines_main_meters = 1000,
                      pois = pois,
                      fac = '/vsis3/lynker-spatial/gridded-resources/fac.vrt',
                      fdr = '/vsis3/lynker-spatial/gridded-resources/fdr.vrt',
                      outfile = "tutorial/refactor.gpkg")
```

## Outputs 

To get a high level understanding of what happened with this "refactor", we can look at the length distributions:

```{r, echo = FALSE}
reference = read_hydrofabric("tutorial/poudre.gpkg")
refactor  = read_hydrofabric("tutorial/refactored.gpkg")

refactor$flowpaths$LENGTHKM = add_lengthkm(refactor$flowpaths)
refactor$catchments$areasqkm = add_areasqkm(refactor$catchments)

reference$catchments$areasqkm = add_areasqkm(reference$catchments)
reference$flowpaths$LENGTHKM = add_lengthkm(reference$flowpaths)

ggplot() + 
  geom_density(data = refactor$flowpaths, aes(x = LENGTHKM), color = "blue", lwd = 3) + 
  geom_density(data = reference$flowpaths, aes(x = LENGTHKM), color = "red", lwd = 3) + 
  xlim(0,10) +
  ylim(0,.75) +
  geom_vline(xintercept = 1, size = 1) + 
  theme_light() + 
  labs(x = "Length (km)", y = "Density",  title = "Length Distribution", 
       subtitle = paste0(sum(reference$flowpaths$LENGTHKM >= 10), ' flowlines from reference (>10 km)\n',
                         sum(refactor$flowpaths$LENGTHKM >= 10), ' flowpaths removed from reference (>10 km)')) +
  geom_label( aes(x=1, y=0.75, label= "Minimum Length"), color="black") +
  geom_label( aes(x=2, y=0.5, label=paste(nrow(reference$flowpaths), "\nreference flowlines")), color="red", fill = "white") +
  geom_label( aes(x=5, y=0.2, label= paste(nrow(refactor$flowpaths), "\nrefactored flowpaths")), color="blue", fill = "white") 
```

And the area distributions:

```{r, echo = FALSE}
ggplot() + 
  geom_density(data = refactor$catchments, aes(x = areasqkm), color = "blue", lwd = 3) + 
  geom_density(data = reference$catchments, aes(x = areasqkm), color = "red", lwd = 3) + 
  xlim(0,25) +
  ylim(0,.6) +
  geom_vline(xintercept = 3) + 
  geom_vline(xintercept = 10, size = 1) + 
  geom_vline(xintercept = 15) + 
  theme_light() + 
  labs(x = expression("Area (km²)"),  title = "Area Distribution", 
       subtitle = paste0(sum(reference$catchments$areasqkm >= 25), ' catchments removed from reference (>25 km²)\n',
                         sum(refactor$catchments$areasqkm >= 25), ' divides removed from refactored (>25 km²)')) +
  annotate("rect", xmin = 3, xmax = 15, ymin = 0, ymax = .6,  alpha = .1) + 
  scale_y_continuous("Density", expand = c(0,0)) + 
  geom_label( aes(x=10, y=0.5, label= "Idealized Range"), color="black") +
  geom_label( aes(x=4, y=0.4, label=paste(nrow(reference$catchments), "\nreference catchments")), color="red", fill = "white") +
  geom_label( aes(x=6.5, y=0.2, label= paste(nrow(refactor$catchments), "\nrefactored divides")), color="blue") 
  
```

Lastly, we look at the feature count of the network:

```{r, echo = FALSE}

d = data.frame(type = c("Reference", "Refactor"), num = c(nrow(reference$catchments), nrow(refactor$catchments)))

ggplot() + 
  geom_col(data = d, aes(x = type, y = num)) + 
  theme_light() +
  labs(title = "Reference vs Refactor Features", x = "Type", y = "Number of Features")
  
```


- Finally, we can zoom into a layer of this network to see what changes exist.

- In the figure below, the white edges represent the `reference` catchment network, while the black edges represent the refactored network

- Since refactoring requires the preservation of the flowpath network, the blue lines are representative of both the reference and refactored network with the caveat they are broken and different places.

```{r, echo = FALSE}
knitr::include_graphics('../man/figures/refactored-network.png')
```


# 2. Running the Process: Aggregating

- Aggregation is a primarily a divide oriented workflow. It collapses the network to provide a new discretization.

- Two aggregation methods:
    - To POIs - you define network outlets (NHM and SPARROW)
    - To a statistical distribution, with or w/o enforced POIs (NextGen).

```{r, echo = FALSE}
knitr::include_graphics('../man/figures/level3.png')
```


| Parameter        | Purpose           | Elected Value  | 
| ------------- |:-------------:| -----:| 
| ideal_size_sqkm    | the maximum length flowpath desired in the output. | 10 |
| min_length_km      | the minimum length of inter-confluence flowpath desired in the output. | 1 |
| min_area_sqkm      | the minimum length of between-confluence flowpaths. | 3 |


Here, a `hydrolocation` POINT layer can be passed to help direct the aggregation, but for simplicity is ignored here:

## Example

```{r, eval = FALSE}

hydrolocations = read_sf("tutorial/refactored.gpkg", 'lookup_table') %>% 
  inner_join(pois, by = c("NHDPlusV2_COMID" = "hf_id")) %>% 
  select(poi_id, NHDPlusV2_COMID, id = reconciled_ID) %>% 
  distinct()

aggregate_to_distribution(gpkg = "tutorial/refactored.gpkg",
                          hydrolocations = mutate(pois, id = hf_id),
                          ideal_size_sqkm = 10, 
                          min_length_km = 1, 
                          min_area_sqkm = 3, 
                          outfile = "tutorial/aggregated.gpkg", 
                          overwrite = TRUE)
```

## Outputs 

To get a high level understanding of what happens with this "refactor", we can look at the length distributions:

```{r, echo = FALSE}
agg = read_hydrofabric("tutorial/aggregated.gpkg")

ggplot() + 
  geom_density(data = refactor$flowpaths,  aes(x = LENGTHKM), color = "blue", lwd = 3) + 
  geom_density(data = reference$flowpaths, aes(x = LENGTHKM), color = "red", lwd = 3) + 
  geom_density(data = agg$flowpaths, aes(x = lengthkm), color = "green", lwd = 3) + 
  xlim(0,10) +
  ylim(0,.75) +
  geom_vline(xintercept = 1, size = 1) + 
  theme_light() + 
  labs(x = "Length (km)", y = "Density",  title = "Length Distribution", 
       subtitle = paste0(sum(reference$flowpaths$LENGTHKM >= 10), ' flowlines from reference (>10 km)\n',
                         sum(refactor$flowpaths$LENGTHKM >= 10), ' flowpaths removed from refactored (>10 km)\n',
                         sum(agg$flowpaths$lengthkm >= 10), ' flowpaths removed from aggregated (>10 km)\n')) +
  geom_label( aes(x=1, y=0.75, label= "Minimum Length"), color="black") +
  geom_label( aes(x=2, y=0.5, label=paste(nrow(reference$flowpaths), "\nreference flowlines")), color="red", fill = "white") +
  geom_label( aes(x=5, y=0.3, label= paste(nrow(refactor$flowpaths), "\nrefactored flowpaths")), color="blue", fill = "white") +
  geom_label( aes(x=8, y=0.2, label= paste(nrow(agg$flowpaths), "\naggregated flowpaths")), color="darkgreen", fill = "white")
```

And the area distributions:

```{r, echo = FALSE}
ggplot() + 
  geom_density(data = refactor$catchments, aes(x = areasqkm), color = "blue", lwd = 3) + 
  geom_density(data = reference$catchments, aes(x = areasqkm), color = "red", lwd = 3) + 
  geom_density(data = agg$catchments, aes(x = areasqkm), color = "green", lwd = 3) + 
  xlim(0,25) +
  ylim(0,.6) +
  geom_vline(xintercept = 3) + 
  geom_vline(xintercept = 10, size = 1) + 
  geom_vline(xintercept = 15) + 
  theme_light() + 
  labs(x = expression("Area (km²)"),  title = "Area Distribution", 
       subtitle = paste0(sum(reference$catchments$AREASQKM >= 25), ' catchments removed from reference (>25 km²)\n',
                         sum(refactor$catchments$areasqkm >= 25), ' divides removed from refactored (>25 km²)\n',
                         sum(agg$catchments$areasqkm >= 25), ' divides removed from aggregated (>25 km²)\n')) +
  annotate("rect", xmin = 3, xmax = 15, ymin = 0, ymax = .6,  alpha = .1) + 
  scale_y_continuous("Density", expand = c(0,0)) + 
  geom_label( aes(x=10, y=0.5, label= "Idealized Range"), color="black") +
  geom_label( aes(x=4, y=0.4, label=paste(nrow(reference$catchments), "\nreference divides")), color="red", fill = "white") +
  geom_label( aes(x=6.5, y=0.22, label= paste(nrow(refactor$catchments), "\nrefactored divides")), color="blue")  +
   geom_label( aes(x=15, y=0.1, label= paste(nrow(agg$catchments), "\naggregated divides")), color="darkgreen", fill = "white")
  
```

- Finally, we can zoom into a layer of this network to see what changes exist.

- In the left-hand figure below, the white edges represent the `reference` catchment network, the black edges represent the refactored network, and the red represnet the aggregated network

- In the right-hand figure, we can see the blue flowlines (from reference and refactor) that were prunned in the aggregation process.


```{r, echo=FALSE,out.width="45%",fig.show='hold',fig.align='center'}
knitr::include_graphics(c('../man/figures/catchment-dissolving.png', '../man/figures/river-pruning.png'))
```


Lastly, we can look at the cumulative network traits of each fabric:

```{r, echo=FALSE}
data.frame(class=rep(c("Flowpath Length", "Divide Area"), each=3),
                  type=rep(c("Reference", "Refactored", 'Aggregated'),2),
                  num = c(sum(reference$flowpaths$lengthkm),
sum(refactor$flowpaths$LENGTHKM),
sum(agg$flowpaths$lengthkm),
sum(reference$catchments$areasqkm),
sum(refactor$catchments$areasqkm),
sum(agg$catchments$areasqkm))) %>% 
ggplot(aes(x=class, y=num, fill=type)) +
  geom_bar(stat="identity", color="black", position=position_dodge())+
  theme_minimal() + 
  scale_fill_manual(values=c('green', 'blue','red'))
```

```{r}
r = read_hydrofabric("tutorial/aggregated.gpkg")
mapview::mapview(r) + pois
```

# Full Run-through

```{r, eval = FALSE}
hf = get_subset(nldi_feature = list(featureSource = "nwis", featureID = "06752260"), 
                source = "/Users/mjohnson/hydrofabric",
                outfile = "tutorial/poudre.gpkg") |>
     refactor(fac = '/vsis3/lynker-spatial/gridded-resources/fac.vrt',
              fdr = '/vsis3/lynker-spatial/gridded-resources/fdr.vrt',
              outfile = "tutorial/refactor.gpkg") |>
     aggregate_to_distribution(outfile = "tutorial/aggregate.gpkg")
```


With all network manipulations, fundamental network traits change. This requires the utilities to rapidly and efficiently recompute key network metric. The nhdplusTools package provides the option to regenerate all or some of these on the fly using graph algorithms and logic (see [Blodget et al (2023)](https://www.sciencedirect.com/science/article/pii/S1364815223001123))

We will return to the `get_sorted()` utility in the subsetting section

```{r, eval = FALSE}
nhdplusTools::add_plus_network_attributes()
nhdplusTools::get_streamorder()
nhdplusTools::calculate_total_drainage_area()
nhdplusTools::get_sorted()
```

```{r, echo = FALSE}
knitr::include_graphics('../man/figures/figure7.png')
```
